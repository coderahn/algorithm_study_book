# algorithm_study_book

This repository contains my learnings from the book '뇌를 자극하는 알고리즘'. All content in this repository is for educational purposes only. The book is copyrighted, and all rights to the original content are reserved by the author and publisher.

## 1부.자료구조
### 1)링크드 리스트(Linked List)
  - 노드가 다음 노드의 주소를 갖고 있음
  - 배열에 비해 삽입, 삭제가 빠름
  - 특정 위치에 있는 노드를 찾는 연산은 느림(while문으로 Head부터 찾아감)

### 2)더블 링크드 리스트(Doubly Linked List)
  - 링크드 리스트와 비슷한 구조지만 이전 노드 주소를 갖고 있음
  - 양방향 탐색이 가능해서 좀 더 검색속도가 향상됨
  - 추가적인 메모리가 필요(prev, next 두 개의 포인터)

### 3)환형 링크드 리스트
  - 더블 링크드 리스트와 비슷하지만 Head와 Tail이 연결된 구조
  - 꼬리를 무는 용을 생각(Head->PrevNode == Tail, Tail->NextNode == Head)

### 4)스택
  - LIFO구조
  - 배열로 만드는 스택, 링크드리스트로 만드는 스택이 있음
  - 자동메모리도 스택 구현(변수 선언 후 자동 해제해주는 알고리즘)

  - (1)배열 스택
    - 스택 구조체에 Capacity(용량) 필요
    - 크기를 자동으로 늘려주지 못하며 용량 선언한 만큼의 스택 사용

  - (2)링크드리스트 스택
    - 크기를 자유롭게 늘릴 수 있음(Capacity 불필요)
    - 스택 구조체에 List(헤드), Top(테일)만 필요
      - cf)Tail이 없어도 List->NextNode로 찾아갈 수 있으나 성능 이슈로 Top이 있어야 함

### 5)큐
  - FIFO구조
  - 선입선출
  - push->enqueue, pop->dequeue
  - 배열로 처리하는 순환큐
    - 시작과 끝을 연결하는 큐
    - 전단(Front), 후단(Rear) 포인터가 필요함
    - 후단과 전단이 같으면 비어있는 것을 의미
    - 후단이 전단보다 1 작으면 FULL 상태 의미
    - 그래서 후단은 실제 후단보다 1큼
  - 링크드 리스트를 이용하는 링크드 큐
    - 순환큐보다 직관적이고 쉬움
    - 성능적으로는 순환큐가 더 좋다고 함(링크드큐는 노드 생성, 삭제시 malloc호출
      - cf)Queue->Rear->NextNode = NewNode; //내부적으로 malloc등 호출하여 동적 메모리 할당

### 6)트리
  - 나무를 닮은 자료구조
  - 운영체제의 파일 시스템, 데이터 베이스 트리 자료구조(B*Tree 등) 
  - 뿌리(Root), 가지(Branch), 잎(Left) 3가지 요소로 이루어짐
  - 차수(Degree): 트리 내 노드들 가운데 자식 노드가 가장 많은 노드의 차수
  - 트리표현: 중첩된 괄호, 중첩된 집합, 들여쓰기(윈도우 탐색기) 
  - 노드 표현하기
    - N-링크 표현법: 노드의 차수가 N이면 N개 링크를 가지고 있어서 이 링크들이 각각 자식 노드를 가리키도록 구성하는 방법
    - 왼쪽 자식-오른쪽 형제(LCRS) 표현법: 왼쪽에는 자식, 오른쪽에는 형제 포인터 갖는 노드 구조
      - cf)부모의 모든 자식은 한 줄로 연결된 형제 관계 유지. 부모는 항상 첫번째 자식(LeftChild)만 알고 있으며 나머지 자식들은 첫번째 자식의 오른쪽형제(RightSibling) 체인을 통해 연결.

  - 이진트리(Binary Tree)
    - 하나의 노드가 최대 2개의 자식 노드를 가짐
    - 탐색방식에 따라 전위순회, 중위순회, 후위순회
    - 검색엔진,인덱스 등 다양하게 활용
    - 재귀함수로 구현

  - 수식트리(Expression Tree)
    - 연산자, 피연산자로 만든 트리
    - 연산자는 루트 노트 또는 가지 노드이다.
    - 후위표기식을 기반으로 만드는 트리
      - 후위표기식 뒤에서부터 토큰을 읽어나가면서 계산

  - 분리집합(Disjoint Set)
    - 교집합을 갖지 않는 집합들
    - 서로 공통된 원소를 갖지 않는 집합들(=서로소 집합)
    - 분리 집합 연산은 '합집합'과 '집합 탐색'만 기억하면 됨
    - 부모노드가 자식노드를 참고하는 방식이 아니라 그 반대
    - 노드 구조체에 Parent 값이 있음. 각 집합의 자식들은 Parent값을 갖고 있는 트리 모양
    - Parent값이 없으면 최상위노드로 집합 그 자체
    - 합집합 처리시 Set1, Set2가 있으면, Set2->Parent값을 Set1으로 세팅해줘서 연결해주기만 하면 됨
    - 집합탐색은 Parent값이 없을 때까지 while문 처리로 올라가서 반환하면 됨 

---

## 2부.알고리즘

### 1.정렬

#### 1)버블정렬
  - 이웃요소끼리 비교 후 교환
  - 요소가 n개라면, n-1만큼 교환
  - 데이터가 끝으로 이동하는 모습이 거품이 올라오는 것 상상
  - 정렬 1회 후, 마지막 데이터는 정렬되고 나머지는 정렬이 안 됨. 마지막을 냅두고 다시 정렬..반복
  - O(n²) 시간복잡도로 효율 안 좋으나, 알아둬야 이후 효율적 정렬 알고리즘을 재밌게(?) 공부할 수 있음

#### 2)삽입정렬
  - 정리필요

#### 3)퀵정렬
  - 퀵정렬은 분할정복에 기반한 알고리즘으로 기준 요소 하나 잡아서 해당 기준 데이터보다 작은 것을 왼쪽에 모은 이후 분할 수행을 왼쪽,오른쪽 진행. 이런방식으로 계속 분할하며 진행.
  - 기준요소보다 작은 요소들을 왼쪽으로 밀어야 하는데 자료구조가 배열. 이 상태에서 밀면 이동 비용이 많이 든다.
  - 이걸 해결하기 위해 정찰병2개(Left, Right)를 각각 왼쪽, 오른쪽에 두어서 기준데이터와 비교하는 전략 사용
    - Left는 계속 오른쪽으로 이동하며 기준요소보다 큰지 비교. (크면 멈추기)
    - Right는 계속 왼쪽으로 이동하면서 기준요소보다 작은지 비교. (작으면 멈추기)
    - Left가 멈춘 위치의 데이터와, Right가 멈춘 위치의 데이터를 교환
    - 이런식으로 교환 후 Left, Right가 만나면 기준 요소를 왼쪽 데이터 집합의 마지막요소와 교환하여 종료
    - 위의 과정으로 왼쪽, 오른쪽 정렬되면 왼쪽 오른쪽을 각각 동일한 방식으로 비교(재귀호출 필요)
  - c 표준 라이브러리 qsort() 있음
  - 퀵정렬은 버블, 삽입에 비해 빠르긴 하다. 그러나 최선의 경우와 최악의 경우를 고려
    -최악의 경우는 데이터가 미리 정렬되어 있거나, 역순으로 정렬되어 있는 경우

### 2. 탐색
  - 순차탐색, 이진탐색, 이진탐색 트리, 레드블랙 트리
  - 1) 순차탐색
    - 순서대로 앞에서부터 찾는 것. 호율 안 좋지만 버그 없고 데이터 적으면 자주 사용
    - 자기 구성 순차 탐색: 자주 찾는 걸 가까운 곳(앞)에 배치
      - 전진 이동법: 찾은 요소를 맨 앞으로 이동
      - 전위법: 찾은 요소를 한칸씩 앞으로 이동
      - 계수법: 탐색된 횟수를 별도 공간에 저장 후 높은 순으로 데이터 집합 재구성
  - 2) 이진탐색
    - 정렬된 데이터 집합에서 사용 가능한 고속 탐색 알고리즘
    - 탐색범위를 1/2씩 줄여나가는 방식
    - 방법
      - 중앙요소 찾기((Left + Right) / 2)
      - 목표값과 중앙값 비교. 
        - 중앙값보다 목표값이 크면 오른쪽 이진탐색 새로 순회(Left+1)
        - 중앙값보다 목표값이 작으면 왼쪽 이진탐색 새로 순회(Right-1)
      - 찾을 때까지 반복..
    - C 표준라이브러리 이진 함수 bsearch()
  - 3) 이진 탐색 트리
    - 탐색을 위한 이진 트리
    - 이진탐색과 차이점
      - 이진탐색은 배열인 경우만 사용 가능
      - 이진탐색트리는 링크드 리스트에서 사용 가능
    - 자식이 최대 2개뿐인 노드로만 이루어져있음
    - 이진트리와 차이점은 왼쪽자식은 부모보다 작고, 오른쪽은 큼(무조건)
    - 제거가 어려움(리프노드의 자식노드가 없는 경우, 1개인 경우, 2개인경우에 따라 다름)
    - 단점: 기형적으로 성장하면 검색효율 극단적으로 떨어뜨림
  - 4) 레드 블랙 트리
    - 진행예정

### 3.우선순위 큐와 힙

#### 1)우선순위 큐
  - 큐는 큐인데 우선순위가 부여된 큐. 삽입시 맨 뒤에부터 삽입이 아니라 우선순위에 맞게 삽입 됨
  - 삽입은 우선순위에 따라, 삭제는 전단 삭제
  - 우선순위 큐를 효율적으로 구현하려면 힙 자료구조를 알아야 함

#### 2)힙
  - 메모리에서의 힙과 다름
  - 힙 순서 속성을 만족하는 완전 이진 트리
  - 힙 순서 속성? -> 트리 내의 모든 노드가 부모 노드보다 커야 한다는 규칙

---

## 기타정리(TIL)

### 241208(일)

#### memset: 메모리 블록을 특정 값으로 초기화

```c
// C 언어 코드 예시
#include <stdio.h>

int main() {
    //트리구조체 선언되어있다고 가정(Tree->Data = 2)
    
    char Temp[2];

    memset(Temp, 0, sizeof(Temp)); //Temp에 0으로 값 초기화
    Temp[0] = Tree->Data; //Temp[0]에 값 세팅, Temp[1]은 '\0'으로 문자열 종료 문자
}
```

#### visual studio code(vscode) pull 오류

저번에 다른 컴퓨터로 readme를 github에서 수정<br>
vscode에서 pull 받으려는데 오류<br>
로컬,리모트 서로 다른 커밋을 갖고 있기 때문<br>
```shell git config pull.rebase false  # 병합 방식 사용 ```<br>
다시 pull하면 처리 완료<br>
충돌난 부분 수정 해야함<br>
  - Accept Incomming Change, Accept Current Change있는데 전자 누르면 원격꺼 덮어쓸 수 있음


### 241209(월)

#### 완전 이진 트리?

1.모든 레벨이 꽉 차야 함<br>
2.마지막 레벨만 예외적으로 덜 차있을 수 있음<br>
3.노드가 왼쪽부터 오른쪽으로 채워진다<br>

### 241211(수)

파트1인 자료구조를 1회 해봤음<br>
이중 포인터에 대한 헷깔림이 여전히 있음<br>
처음 링크드 리스트부터 다시 해보니 조금 더 익숙해지긴 함<br>
이걸 추천해준 유튜브는 여러번 따라 해보고 이후 안 보고 바꿔보는 등의 방식으로 헀다고함. 그리고 소설처럼 읽기<br>
 
 ### 241213(금)

1)<br>
버블정렬에서 호출시 BubbleSort(DataSet, Length) 이런식으로 호출<br>
근데 포인터로 안 넘기면 값이 복사되서 변경 없지 않나? -> 배열은 그 자체로 넘기면 포인터로 처리됨(첫요소)<br>

2)<br>
C언어는 배열 사이즈 구하는 게 없음. sizeof 배열 / sizeof 배열[0] 이런식으로 구해야함<br>

### 241214(토)

1)<br>
*링크드리스트 스택 만들 때, LLS_CreateNode(char* NewData)에서 strcpy(NewNode->Data, NewData) 이유<br>
C언어에서 int, float등 기본형은 값복사 해서 써도 됨(NewNode->Data = NewData)<br>
그러나 char*같은 포인터형을 쓸 때는 NewNode->Data = NewData같이 쓸 경우 Data와 NewData가 같은 주소를 참조<br>
그럴경우 NewData변경시 Data가 변경되는 등의 문제가 발생함. strcpy로 새롭게 만들어 써야함(NewData값을 Data메모리공간에 복사)

2)<br>
*memmove 작동방식 파악 필요(생각한대로 안 동작함..)

### 241215(일)

1)memmove 작동방식<br>
memmove(목적지 주소, 출발지 주소, 복사할 사이즈) 함수에 대한 오해..<br>
memmove는 출발지 주소의 첫번째 값을 단순히 목적지 주소로 복사하는게 아니라 '복사할 사이즈'만큼 복사함
삽입정렬에서 비교 후 뒤로 미는 로직에서 나오는 memmove(&DataSet[j+1], &DataSet[j], sizeof(DataSet[0]) * (i-j))<br>
위 로직은 [j]번쨰 주소값을 [j+1](다음) 주소로 3번째 매개변수(사이즈)만큼 이동시킴<br>
그러면 뒤의 j+1 값이 덮어써지지만, 그 앞에서 value로 세팅해둔 임시값으로 j위치에 삽입하여 처리 가능

### 241225(수)

1)const?<br>
- 매개변수에 const붙으면 함수 내에서 수정 불가(읽기전용으로 인식하도록)<br>

2)함수 포인터<br>
- 매개변수로 함수 포인터를 받을 수 있음<br>
- 여러방식으로 구현된 함수를 넘길 수 있음<br>

```c
//c언어 코드 예시
#include <stdio.h>

// 두 정수를 연산하는 함수 타입
typedef int (*Operation)(int, int);

// 덧셈 함수
int add(int a, int b) {
    return a + b;
}

// 뺄셈 함수
int subtract(int a, int b) {
    return a - b;
}

// 연산을 수행하는 함수 (함수 포인터를 매개변수로 받음)
void calculate(int x, int y, Operation op) {
    printf("Result: %d\n", op(x, y));
}

int main() {
    int a = 10, b = 5;

    // 함수 포인터로 add 전달
    calculate(a, b, add);

    // 함수 포인터로 subtract 전달
    calculate(a, b, subtract);

    return 0;
}
```

### 250102(목)

1)realloc
- reallocation
- 이미 할당된 메모리 크기 조정할때 사용
